{"version":3,"sources":["webpack:///./node_modules/html-to-image/es/util.js","webpack:///./node_modules/html-to-image/es/getBlobFromURL.js","webpack:///./node_modules/html-to-image/es/clonePseudoElements.js","webpack:///./node_modules/html-to-image/es/cloneNode.js","webpack:///./node_modules/html-to-image/es/embedResources.js","webpack:///./node_modules/html-to-image/es/embedImages.js","webpack:///./node_modules/html-to-image/es/embedWebFonts.js","webpack:///./node_modules/html-to-image/es/createSvgDataURL.js","webpack:///./node_modules/html-to-image/es/applyStyleWithOptions.js","webpack:///./node_modules/html-to-image/es/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","WOFF","JPEG","mimes","woff","woff2","ttf","eot","png","jpg","jpeg","gif","tiff","svg","uuid","counter","random","Math","pow","toString","slice","getExtension","url","match","exec","getMimeType","ext","toLowerCase","delay","ms","args","setTimeout","isDataUrl","search","toDataURL","content","mimeType","getDataURLContent","dataURL","split","toArray","arrayLike","i","l","length","push","px","node","styleProperty","val","window","getComputedStyle","getPropertyValue","parseFloat","replace","getNodeWidth","leftBorder","rightBorder","clientWidth","getNodeHeight","topBorder","bottomBorder","clientHeight","getPixelRatio","ratio","FINAL_PROCESS","process","env","devicePixelRatio","parseInt","isNaN","createImage","image","Image","onload","onerror","crossOrigin","src","svgToDataURL","this","XMLSerializer","serializeToString","encodeURIComponent","html","TIMEOUT","cache","isFont","filename","test","getBlobFromURL","options","href","cacheBust","Date","getTime","failed","reason","placeholder","imagePlaceholder","parts","msg","message","console","error","deferred","fetch","res","blob","contentType","headers","get","reader","FileReader","onloadend","readAsDataURL","req","XMLHttpRequest","timeout","Error","readyState","status","encoder","getResponseHeader","response","onreadystatechange","ontimeout","responseType","open","send","promise","catch","clonePseudoElements","nativeNode","clonedNode","pseudos","forEach","pseudo","clonePseudoElement","Pseudo","style","className","err","styleElement","document","createElement","appendChild","getPseudoElementStyle","selector","cssText","formatCssText","formatCssProperties","createTextNode","map","name","priority","getPropertyPriority","join","cloneSingleNode","HTMLCanvasElement","cloneNode","HTMLVideoElement","poster","data","cloneChildren","_a","children","shadowRoot","childNodes","reduce","child","clonedChild","decorate","Element","cloneCssStyle","cloneInputValue","source","target","setProperty","HTMLTextAreaElement","innerHTML","HTMLInputElement","setAttribute","isRoot","filter","URL_REGEX","URL_WITH_FORMAT_REGEX","FONT_SRC_REGEX","shouldEmbed","string","embedResources","cssString","baseUrl","filteredCssString","filterPreferredFontFormat","parseURLs","urls","ret","str","preferredFontFormat","format","raw","quotation","resourceURL","baseURL","resolvedURL","resolveUrl","urlToRegex","location","protocol","doc","implementation","createHTMLDocument","base","a","head","body","RegExp","embedImages","embedBackground","embedImageNode","embedChildren","background","HTMLImageElement","srcset","deferreds","all","cssFetchPromiseStore","parseWebFontRules","ownerDocument","styleSheets","getCssRules","getWebFontRules","embedWebFonts","fontEmbedCss","getWebFontCss","styleNode","sytleContent","firstChild","insertBefore","rules","rule","parentStyleSheet","cssStrings","promises","sheet","cssRules","item","index","type","CSSRule","IMPORT_RULE","importIndex","fetchCSS","embedFonts","parsed","parseCSS","insertRule","startsWith","log","inline","find","FONT_FACE_RULE","undefined","css","cssKeyframeRegex","combinedCSSRegex","cssCommentsRegex","importRegex","keyframesRegex","arr","unified","lastIndex","text","resolved","regexUrlFind","fontLocations","fontLoadedPromises","URL","addEventListener","createSvgDataURL","width","height","xmlns","createElementNS","foreignObject","setAttributeNS","applyStyleWithOptions","backgroundColor","manual","Object","keys","key","getImageSize","domNode","toSvg","toCanvas","canvas","context","getContext","pixelRatio","canvasWidth","canvasHeight","fillStyle","fillRect","drawImage","toPng"],"mappings":"mJAAA,IAAIA,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAC1E,SAASC,EAAMC,GAAS,OAAOA,aAAiBH,EAAIG,EAAQ,IAAIH,GAAE,SAAUI,GAAWA,EAAQD,MAC/F,OAAO,IAAKH,IAAMA,EAAIK,WAAU,SAAUD,EAASE,GAC/C,SAASC,EAAUJ,GAAS,IAAMK,EAAKP,EAAUQ,KAAKN,IAAW,MAAOO,GAAKJ,EAAOI,IACpF,SAASC,EAASR,GAAS,IAAMK,EAAKP,EAAU,SAASE,IAAW,MAAOO,GAAKJ,EAAOI,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOT,OAASD,EAAMU,EAAOT,OAAOW,KAAKP,EAAWI,GAClGH,GAAMP,EAAYA,EAAUc,MAAMjB,EAASC,GAAc,KAAKU,YAGtE,MAAMO,EAAO,wBACPC,EAAO,aACPC,EAAQ,CACVC,KAAMH,EACNI,MAAOJ,EACPK,IAAK,4BACLC,IAAK,gCACLC,IAAK,YACLC,IAAKP,EACLQ,KAAMR,EACNS,IAAK,YACLC,KAAM,aACNC,IAAK,iBAEIC,EAAO,WAGhB,IAAIC,EAAU,EAEd,MAAMC,EAAS,KAAM,QAASC,KAAKD,SAAWC,KAAKC,IAAI,GAAI,IAAO,GAAGC,SAAS,KAAMC,OAAO,GAC3F,MAAO,KACHL,GAAW,EACJ,IAAIC,MAAWD,KARV,GAWb,SAASM,EAAaC,GACzB,MAAMC,EAAQ,gBAAgBC,KAAKF,GACnC,OAAOC,EAAQA,EAAM,GAAK,GAEvB,SAASE,EAAYH,GACxB,MAAMI,EAAML,EAAaC,GAAKK,cAC9B,OAAOxB,EAAMuB,IAAQ,GAElB,SAASE,EAAMC,GAClB,OAAQC,GAAS,IAAIxC,QAASD,IAC1B0C,WAAW,KACP1C,EAAQyC,IACTD,KAGJ,SAASG,EAAUV,GACtB,OAAmC,IAA5BA,EAAIW,OAAO,YAEf,SAASC,EAAUC,EAASC,GAC/B,MAAO,QAAQA,YAAmBD,IAE/B,SAASE,EAAkBC,GAC9B,OAAOA,EAAQC,MAAM,KAAK,GAmBvB,SAASC,EAAQC,GACpB,MAAM5C,EAAS,GACf,IAAK,IAAI6C,EAAI,EAAGC,EAAIF,EAAUG,OAAQF,EAAIC,EAAGD,GAAK,EAC9C7C,EAAOgD,KAAKJ,EAAUC,IAE1B,OAAO7C,EAEX,SAASiD,EAAGC,EAAMC,GACd,MAAMC,EAAMC,OAAOC,iBAAiBJ,GAAMK,iBAAiBJ,GAC3D,OAAOK,WAAWJ,EAAIK,QAAQ,KAAM,KAEjC,SAASC,EAAaR,GACzB,MAAMS,EAAaV,EAAGC,EAAM,qBACtBU,EAAcX,EAAGC,EAAM,sBAC7B,OAAOA,EAAKW,YAAcF,EAAaC,EAEpC,SAASE,EAAcZ,GAC1B,MAAMa,EAAYd,EAAGC,EAAM,oBACrBc,EAAef,EAAGC,EAAM,uBAC9B,OAAOA,EAAKe,aAAeF,EAAYC,EAEpC,SAASE,IACZ,IAAIC,EACAC,EACJ,IACIA,EAAgBC,QAEpB,MAAOvE,IACP,MAAMsD,EAAMgB,GAAiBA,EAAcE,IACrCF,EAAcE,IAAIC,iBAClB,KAON,OANInB,IACAe,EAAQK,SAASpB,EAAK,IAClBqB,MAAMN,KACNA,EAAQ,IAGTA,GAASd,OAAOkB,kBAAoB,EAExC,SAASG,EAAYjD,GACxB,OAAO,IAAIhC,QAAQ,CAACD,EAASE,KACzB,MAAMiF,EAAQ,IAAIC,MAClBD,EAAME,OAAS,IAAMrF,EAAQmF,GAC7BA,EAAMG,QAAUpF,EAChBiF,EAAMI,YAAc,YACpBJ,EAAMK,IAAMvD,IAGb,SAASwD,EAAajE,GACzB,OAAO/B,EAAUiG,UAAM,OAAQ,GAAQ,YACnC,OAAOzF,QAAQD,UACVU,KAAK,KAAM,IAAIiF,eAAgBC,kBAAkBpE,IACjDd,KAAKmF,oBACLnF,KAAMoF,GAAS,oCAAoCA,MC1HhE,MAAMC,EAAU,IACVC,EAAQ,GACd,SAASC,EAAOC,GACZ,MAAO,sBAAsBC,KAAKD,GAE/B,SAASE,EAAenE,EAAKoE,GAChC,IAAIC,EAAOrE,EAAIgC,QAAQ,OAAQ,IAI/B,GAHIgC,EAAOK,KACPA,EAAOA,EAAKrC,QAAQ,OAAQ,KAE5B+B,EAAMM,GACN,OAAON,EAAMM,GAIbD,EAAQE,YAERtE,IAAQ,KAAKkE,KAAKlE,GAAO,IAAM,MAAO,IAAIuE,MAAOC,WAErD,MAAMC,EAAUC,IACZ,IAAIC,EAAc,GAClB,GAAIP,EAAQQ,iBAAkB,CAC1B,MAAMC,EAAQT,EAAQQ,iBAAiB3D,MAAM,KACzC4D,GAASA,EAAM,KACfF,EAAcE,EAAM,IAG5B,IAAIC,EAAM,6BAA6B9E,EAOvC,OANI0E,IACAI,EAAwB,kBAAXJ,EAAsBA,EAASA,EAAOK,SAEnDD,GACAE,QAAQC,MAAMH,GAEXH,GAELO,EAAWtD,OAAOuD,MAClBvD,OACGuD,MAAMnF,GACNvB,KAAM2G,GAAQA,EAAIC,OAAO5G,KAAM4G,IAAS,CACzCA,OACAC,YAAaF,EAAIG,QAAQC,IAAI,iBAAmB,OAE/C/G,KAAK,EAAG4G,OAAMC,iBAAkB,IAAItH,QAAQ,CAACD,EAASE,KACvD,MAAMwH,EAAS,IAAIC,WACnBD,EAAOE,UAAY,IAAM5H,EAAQ,CAC7BuH,cACAD,KAAMI,EAAOlH,SAEjBkH,EAAOpC,QAAUpF,EACjBwH,EAAOG,cAAcP,MAEpB5G,KAAK,EAAG4G,OAAMC,kBAAkB,CACjCA,cACAD,KAAMtE,EAAkBsE,MAE1B,IAAIrH,QAAQ,CAACD,EAASE,KACpB,MAAM4H,EAAM,IAAIC,eACVC,EAAU,KACZ9H,EAAO,IAAI+H,MAAM,cAAclC,wCAA8C9D,OAE3ExB,EAAO,KACT,GAAuB,IAAnBqH,EAAII,WACJ,OAEJ,GAAmB,MAAfJ,EAAIK,OAEJ,YADAjI,EAAO,IAAI+H,MAAM,6BAA6BhG,cAAgB6F,EAAIK,WAGtE,MAAMC,EAAU,IAAIT,WACpBS,EAAQR,UAAY,KAChB5H,EAAQ,CACJsH,KAAMtE,EAAkBoF,EAAQ5H,QAChC+G,YAAaO,EAAIO,kBAAkB,iBAAmB,MAG9DD,EAAQP,cAAcC,EAAIQ,WAE9BR,EAAIS,mBAAqB9H,EACzBqH,EAAIU,UAAYR,EAChBF,EAAIW,aAAe,OACnBX,EAAIE,QAAUjC,EACd+B,EAAIY,KAAK,MAAOzG,GAAK,GACrB6F,EAAIa,SAENC,EAAUzB,EAAS0B,MAAMnC,GAG/B,OADAV,EAAMM,GAAQsC,EACPA,EC7FX,IAAI,EA0CG,SAASE,EAAoBC,EAAYC,GAC5C,MAAMC,EAAU,CAAC,UAAW,UAC5BA,EAAQC,QAASC,GAAW,EAAOC,mBAAmBL,EAAYC,EAAYG,KA3ClF,SAAWE,GACP,SAASD,EAAmBL,EAAYC,EAAYG,GAChD,MAAMG,EAAQzF,OAAOC,iBAAiBiF,EAAYI,GAC5CrG,EAAUwG,EAAMvF,iBAAiB,WACvC,GAAgB,KAAZjB,GAA8B,SAAZA,EAClB,OAEJ,MAAMyG,EAAY9H,IAElB,IACIuH,EAAWO,UAAY,GAAGP,EAAWO,aAAaA,IAEtD,MAAOC,GACH,OAEJ,MAAMC,EAAeC,SAASC,cAAc,SAC5CF,EAAaG,YAAYC,EAAsBN,EAAWJ,EAAQG,IAClEN,EAAWY,YAAYH,GAG3B,SAASI,EAAsBN,EAAWJ,EAAQG,GAC9C,MAAMQ,EAAW,IAAIP,KAAaJ,IAC5BY,EAAUT,EAAMS,QAChBC,EAAcV,GACdW,EAAoBX,GAC1B,OAAOI,SAASQ,eAAe,GAAGJ,KAAYC,MAElD,SAASC,EAAcV,GACnB,MAAMxG,EAAUwG,EAAMvF,iBAAiB,WACvC,MAAO,GAAGuF,EAAMS,qBAAqBjH,EAAQmB,QAAQ,OAAQ,QAEjE,SAASgG,EAAoBX,GACzB,OAAOnG,EAAQmG,GACVa,IAAKC,IACN,MAAMrK,EAAQuJ,EAAMvF,iBAAiBqG,GAC/BC,EAAWf,EAAMgB,oBAAoBF,GAC3C,MAAO,GAAGA,MAASrK,IAAQsK,EAAW,cAAgB,QAErDE,KAAK,KAnBdlB,EAAOD,mBAAqBA,GAnBhC,CAwCG,IAAW,EAAS,KC1CvB,IAAI,EAAwC,SAAU1J,EAASC,EAAYC,EAAGC,GAC1E,SAASC,EAAMC,GAAS,OAAOA,aAAiBH,EAAIG,EAAQ,IAAIH,GAAE,SAAUI,GAAWA,EAAQD,MAC/F,OAAO,IAAKH,IAAMA,EAAIK,WAAU,SAAUD,EAASE,GAC/C,SAASC,EAAUJ,GAAS,IAAMK,EAAKP,EAAUQ,KAAKN,IAAW,MAAOO,GAAKJ,EAAOI,IACpF,SAASC,EAASR,GAAS,IAAMK,EAAKP,EAAU,SAASE,IAAW,MAAOO,GAAKJ,EAAOI,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOT,OAASD,EAAMU,EAAOT,OAAOW,KAAKP,EAAWI,GAClGH,GAAMP,EAAYA,EAAUc,MAAMjB,EAASC,GAAc,KAAKU,YAMtE,SAASmK,EAAgB9G,EAAM2C,GAC3B,OAAO,EAAUX,UAAM,OAAQ,GAAQ,YACnC,GAAIhC,aAAgB+G,kBAAmB,CACnC,MAAMxH,EAAUS,EAAKb,YACrB,MAAgB,WAAZI,EACOhD,QAAQD,QAAQ0D,EAAKgH,WAAU,IAEnCxF,EAAYjC,GAEvB,OAAIS,aAAgBiH,kBAAoBjH,EAAKkH,OAClC3K,QAAQD,QAAQ0D,EAAKkH,QACvBlK,KAAMuB,GAAQmE,EAAenE,EAAKoE,IAClC3F,KAAMmK,GAAShI,EAAUgI,EAAKvD,KAAMlF,EAAYsB,EAAKkH,SAAWC,EAAKtD,cACrE7G,KAAMuC,GAAYiC,EAAYjC,IAEhChD,QAAQD,QAAQ0D,EAAKgH,WAAU,OAG9C,SAASI,EAAc/B,EAAYC,EAAY3C,GAC3C,IAAI0E,EACJ,OAAO,EAAUrF,UAAM,OAAQ,GAAQ,YACnC,MAAMsF,EAAW7H,GAA0C,QAAhC4H,EAAKhC,EAAWkC,kBAA+B,IAAPF,EAAgBA,EAAKhC,GAAYmC,YACpG,OAAwB,IAApBF,EAASzH,OACFtD,QAAQD,QAAQgJ,GAEpBgC,EACFG,OAAO,CAAC1K,EAAM2K,IAAU3K,EACxBC,KAAK,IAAMgK,EAAUU,EAAO/E,IAC5B3F,KAAM2K,IACHA,GACArC,EAAWY,YAAYyB,KAE3BpL,QAAQD,WACPU,KAAK,IAAMsI,MAGxB,SAASsC,EAASvC,EAAYC,GAC1B,OAAO,EAAUtD,UAAM,OAAQ,GAAQ,YACnC,OAAMsD,aAAsBuC,QAGrBtL,QAAQD,UACVU,KAAK,IAAM8K,EAAczC,EAAYC,IACrCtI,KAAK,IAAMoI,EAAoBC,EAAYC,IAC3CtI,KAAK,IAAM+K,EAAgB1C,EAAYC,IACvCtI,KAAK,IAAMsI,GANLA,KASnB,SAASwC,EAAczC,EAAYC,GAC/B,MAAM0C,EAAS7H,OAAOC,iBAAiBiF,GACjC4C,EAAS3C,EAAWM,MACrBqC,IAGDD,EAAO3B,QACP4B,EAAO5B,QAAU2B,EAAO3B,QAGxB5G,EAAQuI,GAAQxC,QAASkB,IACrBuB,EAAOC,YAAYxB,EAAMsB,EAAO3H,iBAAiBqG,GAAOsB,EAAOpB,oBAAoBF,OAI/F,SAASqB,EAAgB1C,EAAYC,GAC7BD,aAAsB8C,sBACtB7C,EAAW8C,UAAY/C,EAAWhJ,OAElCgJ,aAAsBgD,kBACtB/C,EAAWgD,aAAa,QAASjD,EAAWhJ,OAG7C,SAAS2K,EAAU3B,EAAY1C,EAAS4F,GAC3C,OAAO,EAAUvG,UAAM,OAAQ,GAAQ,YACnC,OAAKuG,IAAU5F,EAAQ6F,QAAW7F,EAAQ6F,OAAOnD,GAG1C9I,QAAQD,QAAQ+I,GAClBrI,KAAMsI,GAAewB,EAAgBxB,EAAY3C,IACjD3F,KAAMsI,GAAe8B,EAAc/B,EAAYC,EAAY3C,IAC3D3F,KAAMsI,GAAesC,EAASvC,EAAYC,IALpC/I,QAAQD,QAAQ,SCpFnC,MAAMmM,EAAY,6BACZC,EAAwB,6CACxBC,EAAiB,qDAChB,SAASC,EAAYC,GACxB,OAAqC,IAA9BA,EAAO3J,OAAOuJ,GAElB,SAASK,EAAeC,EAAWC,EAASrG,GAC/C,IAAKiG,EAAYG,GACb,OAAOxM,QAAQD,QAAQyM,GAE3B,MAAME,EAAoBC,EAA0BH,EAAWpG,GAC/D,OAAOpG,QAAQD,QAAQ2M,GAClBjM,KAAKmM,GACLnM,KAAMoM,GAASA,EAAK3B,OAAO,CAAC1K,EAAMwB,IAAQxB,EAAKC,KAAMqM,GAAQ,EAAMA,EAAK9K,EAAKyK,EAASrG,IAAWpG,QAAQD,QAAQ2M,KAEnH,SAASC,EAA0BI,GAAK,oBAAEC,IAC7C,OAAQA,EAEFD,EAAI/I,QAAQoI,EAAiBnK,IAC3B,MAAO,EAAM,CACT,MAAOsD,EAAK,CAAE0H,GAAUd,EAAsBjK,KAAKD,IAAU,GAC7D,IAAKgL,EACD,MAAO,GAEX,GAAIA,IAAWD,EACX,MAAO,QAAQzH,QARzBwH,EAaH,SAASH,EAAUG,GACtB,MAAMxM,EAAS,GAKf,OAJAwM,EAAI/I,QAAQkI,EAAW,CAACgB,EAAKC,EAAWnL,KACpCzB,EAAOgD,KAAKvB,GACLkL,IAEJ3M,EAAO0L,OAAQjK,IAASU,EAAUV,IAEtC,SAAS,EAAMwK,EAAWY,EAAaC,EAASjH,EAASoB,GAC5D,MAAM8F,EAAcD,EAAUE,EAAWH,EAAaC,GAAWD,EACjE,OAAOpN,QAAQD,QAAQuN,GAClB7M,KAAMuB,GAAQwF,EAAMA,EAAIxF,GAAOmE,EAAenE,EAAKoE,IACnD3F,KAAMmK,GACa,kBAATA,EACAhI,EAAUgI,EAAMzI,EAAYiL,IAEhCxK,EAAUgI,EAAKvD,KAAMlF,EAAYiL,IAAgBxC,EAAKtD,cAE5D7G,KAAMuC,GAAYwJ,EAAUxI,QAAQwJ,EAAWJ,GAAc,KAAKpK,QAClEvC,KAAMoC,GAAYA,EAAS,IAAMyK,GAE1C,SAASC,EAAWvL,EAAKyK,GAErB,GAAIzK,EAAIC,MAAM,iBACV,OAAOD,EAGX,GAAIA,EAAIC,MAAM,SACV,OAAO2B,OAAO6J,SAASC,SAAW1L,EAGtC,GAAIA,EAAIC,MAAM,aACV,OAAOD,EAEX,MAAM2L,EAAMlE,SAASmE,eAAeC,qBAC9BC,EAAOH,EAAIjE,cAAc,QACzBqE,EAAIJ,EAAIjE,cAAc,KAO5B,OANAiE,EAAIK,KAAKrE,YAAYmE,GACrBH,EAAIM,KAAKtE,YAAYoE,GACjBtB,IACAqB,EAAKzH,KAAOoG,GAEhBsB,EAAE1H,KAAOrE,EACF+L,EAAE1H,KAEb,SAASmH,EAAWxL,GAChB,OAAO,IAAIkM,OAAO,iBAAiB,EAAOlM,gBAAmB,KAEjE,SAAS,EAAOA,GACZ,OAAOA,EAAIgC,QAAQ,2BAA4B,QCjFnD,IAAI,EAAwC,SAAUvE,EAASC,EAAYC,EAAGC,GAC1E,SAASC,EAAMC,GAAS,OAAOA,aAAiBH,EAAIG,EAAQ,IAAIH,GAAE,SAAUI,GAAWA,EAAQD,MAC/F,OAAO,IAAKH,IAAMA,EAAIK,WAAU,SAAUD,EAASE,GAC/C,SAASC,EAAUJ,GAAS,IAAMK,EAAKP,EAAUQ,KAAKN,IAAW,MAAOO,GAAKJ,EAAOI,IACpF,SAASC,EAASR,GAAS,IAAMK,EAAKP,EAAU,SAASE,IAAW,MAAOO,GAAKJ,EAAOI,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOT,OAASD,EAAMU,EAAOT,OAAOW,KAAKP,EAAWI,GAClGH,GAAMP,EAAYA,EAAUc,MAAMjB,EAASC,GAAc,KAAKU,YAM/D,SAAS+N,EAAYpF,EAAY3C,GACpC,OAAO,EAAUX,UAAM,OAAQ,GAAQ,YACnC,OAAMsD,aAAsBuC,QAGrBtL,QAAQD,QAAQgJ,GAClBtI,KAAMgD,GAAS2K,EAAgB3K,EAAM2C,IACrC3F,KAAMgD,GAAS4K,EAAe5K,EAAM2C,IACpC3F,KAAMgD,GAAS6K,EAAc7K,EAAM2C,IAL7BpG,QAAQD,QAAQgJ,MAQnC,SAASqF,EAAgBrF,EAAY3C,GACjC,IAAI0E,EACJ,OAAO,EAAUrF,UAAM,OAAQ,GAAQ,YACnC,MAAM8I,EAAyC,QAA3BzD,EAAK/B,EAAWM,aAA0B,IAAPyB,OAAgB,EAASA,EAAGhH,iBAAiB,cACpG,OAAKyK,EAGEvO,QAAQD,QAAQwO,GAClB9N,KAAM+L,GAAcD,EAAeC,EAAW,KAAMpG,IACpD3F,KAAM+L,IACPzD,EAAWM,MAAMsC,YAAY,aAAca,EAAWzD,EAAWM,MAAMgB,oBAAoB,eACpFtB,IANA/I,QAAQD,QAAQgJ,MAUnC,SAASsF,EAAetF,EAAY3C,GAChC,KAAM2C,aAAsByF,mBAAqB9L,EAAUqG,EAAWxD,KAClE,OAAOvF,QAAQD,QAAQgJ,GAE3B,MAAMxD,EAAMwD,EAAWxD,IACvB,OAAOvF,QAAQD,QAAQwF,GAClB9E,KAAMuB,GAAQmE,EAAenE,EAAKoE,IAClC3F,KAAMmK,GAAShI,EAAUgI,EAAKvD,KAAMlF,EAAYoD,IAAQqF,EAAKtD,cAC7D7G,KAAMuC,GAAY,IAAIhD,QAAQ,CAACD,EAASE,KACzC8I,EAAW3D,OAASrF,EACpBgJ,EAAW1D,QAAUpF,EACrB8I,EAAW0F,OAAS,GACpB1F,EAAWxD,IAAMvC,KAEhBvC,KAAK,IAAMsI,EAAY,IAAMA,GAEtC,SAASuF,EAAcvF,EAAY3C,GAC/B,OAAO,EAAUX,UAAM,OAAQ,GAAQ,YACnC,MAAMsF,EAAW7H,EAAQ6F,EAAWkC,YAC9ByD,EAAY3D,EAASb,IAAKiB,GAAUgD,EAAYhD,EAAO/E,IAC7D,OAAOpG,QAAQ2O,IAAID,GAAWjO,KAAK,IAAMsI,MC1DjD,IAAI,EAAwC,SAAUtJ,EAASC,EAAYC,EAAGC,GAC1E,SAASC,EAAMC,GAAS,OAAOA,aAAiBH,EAAIG,EAAQ,IAAIH,GAAE,SAAUI,GAAWA,EAAQD,MAC/F,OAAO,IAAKH,IAAMA,EAAIK,WAAU,SAAUD,EAASE,GAC/C,SAASC,EAAUJ,GAAS,IAAMK,EAAKP,EAAUQ,KAAKN,IAAW,MAAOO,GAAKJ,EAAOI,IACpF,SAASC,EAASR,GAAS,IAAMK,EAAKP,EAAU,SAASE,IAAW,MAAOO,GAAKJ,EAAOI,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOT,OAASD,EAAMU,EAAOT,OAAOW,KAAKP,EAAWI,GAClGH,GAAMP,EAAYA,EAAUc,MAAMjB,EAASC,GAAc,KAAKU,YAKtE,MAAMwO,EAAuB,GACtB,SAASC,EAAkB9F,GAC9B,OAAO,EAAUtD,UAAM,OAAQ,GAAQ,YACnC,OAAO,IAAIzF,QAAQ,CAACD,EAASE,KACpB8I,EAAW+F,eACZ7O,EAAO,IAAI+H,MAAM,8CAErBjI,EAAQmD,EAAQ6F,EAAW+F,cAAcC,gBAExCtO,KAAMsO,GAAgBC,GAAYD,IAClCtO,KAAKwO,OAGX,SAASC,EAAcnG,EAAY3C,GACtC,OAAO,EAAUX,UAAM,OAAQ,GAAQ,YACnC,OAAgC,MAAxBW,EAAQ+I,aACVnP,QAAQD,QAAQqG,EAAQ+I,cACxBC,GAAcrG,EAAY3C,IAAU3F,KAAM+L,IAC5C,MAAM6C,EAAY5F,SAASC,cAAc,SACnC4F,EAAe7F,SAASQ,eAAeuC,GAQ7C,OAPA6C,EAAU1F,YAAY2F,GAClBvG,EAAWwG,WACXxG,EAAWyG,aAAaH,EAAWtG,EAAWwG,YAG9CxG,EAAWY,YAAY0F,GAEpBtG,OAIZ,SAASqG,GAAc3L,EAAM2C,GAChC,OAAO,EAAUX,UAAM,OAAQ,GAAQ,YACnC,OAAOoJ,EAAkBpL,GACpBhD,KAAMgP,GAAUzP,QAAQ2O,IAAIc,EAAMvF,IAAKwF,IACxC,MAAMjD,EAAUiD,EAAKC,iBACfD,EAAKC,iBAAiBtJ,KACtB,KACN,OAAOkG,EAAemD,EAAK5F,QAAS2C,EAASrG,OAE5C3F,KAAMmP,GAAeA,EAAWtF,KAAK,UAG3C,SAAS0E,GAAYD,GACxB,OAAO,EAAUtJ,UAAM,OAAQ,GAAQ,YACnC,MAAMqH,EAAM,GACN+C,EAAW,GAmDjB,OAjDAd,EAAY9F,QAAS6G,IACjB,GAAI,aAAcA,EACd,IACI5M,EAAQ4M,EAAMC,UAAU9G,QAAQ,CAAC+G,EAAMC,KACnC,GAAID,EAAKE,OAASC,QAAQC,YAAa,CACnC,IAAIC,EAAcJ,EAAQ,EAC1BJ,EAAStM,KAAK+M,GAASN,EAAK3J,KAAMyJ,GAC7BrP,KAAK8P,IACL9P,KAAMqJ,IACP,MAAM0G,EAASC,GAAS3G,GACxB0G,EAAOvH,QAASyG,IACZ,IACII,EAAMY,WAAWhB,EAAMA,EAAKiB,WAAW,WAChCN,GAA4B,EAC7BP,EAAMC,SAASzM,QAEzB,MAAO2D,GACHD,QAAQ4J,IAAI,uCAAwC,CAChDlB,OACAzI,eAKX2B,MAAOvI,IACR2G,QAAQ4J,IAAI,2BAA4BvQ,EAAEwB,kBAK1D,MAAOxB,GACH,MAAMwQ,EAAS9B,EAAY+B,KAAM/C,GAAiB,OAAXA,EAAE1H,OAAkBoD,SAASsF,YAAY,GAC9D,MAAde,EAAMzJ,MACNwJ,EAAStM,KAAK+M,GAASR,EAAMzJ,KAAMwK,GAC9BpQ,KAAK8P,IACL9P,KAAMqJ,IACP,MAAM0G,EAASC,GAAS3G,GACxB0G,EAAOvH,QAASyG,IACZmB,EAAOH,WAAWhB,EAAMI,EAAMC,SAASzM,YAG1CsF,MAAOvI,IACR2G,QAAQ4J,IAAI,kCAAmCvQ,EAAEwB,eAGzDmF,QAAQ4J,IAAI,iCAAkCvQ,EAAEwB,eAIrD7B,QAAQ2O,IAAIkB,GAAUpP,KAAK,KAE9BsO,EAAY9F,QAAS6G,IACjB,GAAI,aAAcA,EACd,IACI5M,EAAQ4M,EAAMC,UAAU9G,QAAS+G,IAC7BlD,EAAIvJ,KAAKyM,KAGjB,MAAO3P,GACH2G,QAAQ4J,IAAI,sCAAsCd,EAAMzJ,KAAQhG,EAAEwB,eAIvEiL,OAInB,SAASmC,GAAgBc,GACrB,OAAOA,EACF9D,OAAQyD,GAASA,EAAKQ,OAASC,QAAQY,gBACvC9E,OAAQyD,GAASrD,EAAYqD,EAAKrG,MAAMvF,iBAAiB,SAElE,SAAS2M,GAAShF,GACd,QAAeuF,IAAXvF,EACA,MAAO,GAEX,IAAI3B,EAAU2B,EACd,MAAMwF,EAAM,GACNC,EAAmB,mDACnBC,EAAmB,6GAEnBC,EAAmB,uBACnBC,EAAc,yCAEpBvH,EAAUA,EAAQ9F,QAAQoN,EAAkB,IAC5C,MAAME,EAAiB,IAAIpD,OAAOgD,EAAkB,MACpD,IAAIK,EACJ,MAAO,EAAM,CAET,GADAA,EAAMD,EAAepP,KAAK4H,GACd,OAARyH,EACA,MAEJN,EAAI1N,KAAKgO,EAAI,IAEjBzH,EAAUA,EAAQ9F,QAAQsN,EAAgB,IAE1C,MAAME,EAAU,IAAItD,OAAOiD,EAAkB,MAC7C,MAAO,EAAM,CAET,GADAI,EAAMF,EAAYnP,KAAK4H,GACX,OAARyH,EAAc,CAEd,GADAA,EAAMC,EAAQtP,KAAK4H,GACP,OAARyH,EACA,MAGAF,EAAYI,UAAYD,EAAQC,eAIpCD,EAAQC,UAAYJ,EAAYI,UAEpCR,EAAI1N,KAAKgO,EAAI,IAEjB,OAAON,EAEX,SAASX,GAAStO,EAAK8N,GACnB,GAAIlB,EAAqB5M,GACrB,OAAO4M,EAAqB5M,GAEhC,MAAM2G,EAAUxB,MAAMnF,GAAKvB,KAAM2G,IACtB,CACHpF,MACA8H,QAAS1C,EAAIsK,SAEjBrR,IACA2G,QAAQ4J,IAAI,uBAAwBvQ,EAAEwB,cAG1C,OADA+M,EAAqB5M,GAAO2G,EACrBA,EAEX,SAAS4H,GAAW3F,GAChB,OAAO,EAAUnF,UAAM,OAAQ,GAAQ,YACnC,OAAOmF,EAAKd,QAAQrJ,KAAMkR,IACtB,IAAI7H,EAAU6H,EACd,MAAMC,EAAe,8BACfC,EAAgB/H,EAAQ7H,MAAM,kBAAoB,GAClD6P,EAAqBD,EAAc3H,IAAKuD,IAC1C,IAAIzL,EAAMyL,EAASzJ,QAAQ4N,EAAc,MACzC,IAAK5P,EAAI2O,WAAW,YAAa,CAC7B,MAAMlF,EAASb,EAAK5I,IACpBA,EAAM,IAAI+P,IAAI/P,EAAKyJ,GAAQpF,KAE/B,OAAO,IAAIrG,QAAQ,CAACD,EAASE,KACzBkH,MAAMnF,GACDvB,KAAM2G,GAAQA,EAAIC,QAClB5G,KAAM4G,IACP,MAAMI,EAAS,IAAIC,WACnBD,EAAOuK,iBAAiB,OAAS5K,IAE7B0C,EAAUA,EAAQ9F,QAAQyJ,EAAU,OAAOhG,EAAOlH,WAClDR,EAAQ,CAAC0N,EAAUhG,EAAOlH,WAE9BkH,EAAOG,cAAcP,KAEpBuB,MAAM3I,OAGnB,OAAOD,QAAQ2O,IAAImD,GAAoBrR,KAAK,IAAMqJ,QCvNvD,SAASmI,GAAiBlJ,EAAYmJ,EAAOC,GAChD,MAAMC,EAAQ,6BACR7Q,EAAMkI,SAAS4I,gBAAgBD,EAAO,OACtCE,EAAgB7I,SAAS4I,gBAAgBD,EAAO,iBAWtD,OAVA7Q,EAAIgR,eAAe,GAAI,QAAS,GAAGL,GACnC3Q,EAAIgR,eAAe,GAAI,SAAU,GAAGJ,GACpC5Q,EAAIgR,eAAe,GAAI,UAAW,OAAOL,KAASC,KAClDG,EAAcC,eAAe,GAAI,QAAS,QAC1CD,EAAcC,eAAe,GAAI,SAAU,QAC3CD,EAAcC,eAAe,GAAI,IAAK,KACtCD,EAAcC,eAAe,GAAI,IAAK,KACtCD,EAAcC,eAAe,GAAI,4BAA6B,QAC9DhR,EAAIoI,YAAY2I,GAChBA,EAAc3I,YAAYZ,GACnBvD,EAAajE,GCfjB,SAASiR,GAAsBzJ,EAAY3C,GAC9C,MAAM,MAAEiD,GAAUN,EACd3C,EAAQqM,kBACRpJ,EAAMoJ,gBAAkBrM,EAAQqM,iBAEhCrM,EAAQ8L,QACR7I,EAAM6I,MAAW9L,EAAQ8L,MAAX,MAEd9L,EAAQ+L,SACR9I,EAAM8I,OAAY/L,EAAQ+L,OAAX,MAEnB,MAAMO,EAAStM,EAAQiD,MAOvB,OANc,MAAVqJ,GACAC,OAAOC,KAAKF,GAAQzJ,QAAS4J,IAEzBxJ,EAAMwJ,GAAOH,EAAOG,KAGrB9J,EClBX,IAAI,GAAwC,SAAUtJ,EAASC,EAAYC,EAAGC,GAC1E,SAASC,EAAMC,GAAS,OAAOA,aAAiBH,EAAIG,EAAQ,IAAIH,GAAE,SAAUI,GAAWA,EAAQD,MAC/F,OAAO,IAAKH,IAAMA,EAAIK,WAAU,SAAUD,EAASE,GAC/C,SAASC,EAAUJ,GAAS,IAAMK,EAAKP,EAAUQ,KAAKN,IAAW,MAAOO,GAAKJ,EAAOI,IACpF,SAASC,EAASR,GAAS,IAAMK,EAAKP,EAAU,SAASE,IAAW,MAAOO,GAAKJ,EAAOI,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOT,OAASD,EAAMU,EAAOT,OAAOW,KAAKP,EAAWI,GAClGH,GAAMP,EAAYA,EAAUc,MAAMjB,EAASC,GAAc,KAAKU,YAStE,SAAS0S,GAAaC,EAAS3M,EAAU,IACrC,MAAM8L,EAAQ9L,EAAQ8L,OAASjO,EAAa8O,GACtCZ,EAAS/L,EAAQ+L,QAAU9N,EAAc0O,GAC/C,MAAO,CAAEb,QAAOC,UAEb,SAASa,GAAMD,EAAS3M,EAAU,IACrC,OAAO,GAAUX,UAAM,OAAQ,GAAQ,YACnC,MAAM,MAAEyM,EAAK,OAAEC,GAAWW,GAAaC,EAAS3M,GAChD,OAAOqE,EAAUsI,EAAS3M,GAAS,GAC9B3F,KAAMsI,GAAemG,EAAcnG,EAAY3C,IAC/C3F,KAAMsI,GAAeoF,EAAYpF,EAAY3C,IAC7C3F,KAAMsI,GAAeyJ,GAAsBzJ,EAAY3C,IACvD3F,KAAMsI,GAAekJ,GAAiBlJ,EAAYmJ,EAAOC,OAI/D,SAASc,GAASF,EAAS3M,EAAU,IACxC,OAAO,GAAUX,UAAM,OAAQ,GAAQ,YACnC,OAAOuN,GAAMD,EAAS3M,GACjB3F,KAAKwE,GACLxE,KAAK6B,EAAM,MACX7B,KAAMyE,IACP,MAAMgO,EAASzJ,SAASC,cAAc,UAChCyJ,EAAUD,EAAOE,WAAW,MAC5B1O,EAAQ0B,EAAQiN,YAAc5O,KAC9B,MAAEyN,EAAK,OAAEC,GAAWW,GAAaC,EAAS3M,GAC1CkN,EAAclN,EAAQkN,aAAepB,EACrCqB,EAAenN,EAAQmN,cAAgBpB,EAU7C,OATAe,EAAOhB,MAAQoB,EAAc5O,EAC7BwO,EAAOf,OAASoB,EAAe7O,EAC/BwO,EAAO7J,MAAM6I,MAAQ,GAAGoB,EACxBJ,EAAO7J,MAAM8I,OAAS,GAAGoB,EACrBnN,EAAQqM,kBACRU,EAAQK,UAAYpN,EAAQqM,gBAC5BU,EAAQM,SAAS,EAAG,EAAGP,EAAOhB,MAAOgB,EAAOf,SAEhDgB,EAAQO,UAAUxO,EAAO,EAAG,EAAGgO,EAAOhB,MAAOgB,EAAOf,QAC7Ce,OAaZ,SAASS,GAAMZ,EAAS3M,EAAU,IACrC,OAAO,GAAUX,UAAM,OAAQ,GAAQ,YACnC,OAAOwN,GAASF,EAAS3M,GAAS3F,KAAMyS,GAAWA,EAAOtQ","file":"static/js/chunk-2d225fc5.e8f854b4.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n};\nexport const uuid = (function uuid() {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport function getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nexport function getMimeType(url) {\n    const ext = getExtension(url).toLowerCase();\n    return mimes[ext] || '';\n}\nexport function delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(args);\n        }, ms);\n    });\n}\nexport function isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nexport function toDataURL(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nexport function getDataURLContent(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nfunction toBlob(canvas) {\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas.toDataURL().split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], { type: 'image/png' }));\n    });\n}\nexport function canvasToBlob(canvas) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => canvas.toBlob(resolve));\n    }\n    return toBlob(canvas);\n}\nexport function toArray(arrayLike) {\n    const result = [];\n    for (let i = 0, l = arrayLike.length; i < l; i += 1) {\n        result.push(arrayLike[i]);\n    }\n    return result;\n}\nfunction px(node, styleProperty) {\n    const val = window.getComputedStyle(node).getPropertyValue(styleProperty);\n    return parseFloat(val.replace('px', ''));\n}\nexport function getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nexport function getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) { }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.onerror = reject;\n        image.crossOrigin = 'anonymous';\n        image.src = url;\n    });\n}\nexport function svgToDataURL(svg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Promise.resolve()\n            .then(() => new XMLSerializer().serializeToString(svg))\n            .then(encodeURIComponent)\n            .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n    });\n}\nexport function getBlobFromImageURL(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return createImage(url).then((image) => {\n            const { width, height } = image;\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            const ratio = getPixelRatio();\n            canvas.width = width * ratio;\n            canvas.height = height * ratio;\n            canvas.style.width = `${width}`;\n            canvas.style.height = `${height}`;\n            context.scale(ratio, ratio);\n            context.drawImage(image, 0, 0);\n            const dataURL = canvas.toDataURL(getMimeType(url));\n            return getDataURLContent(dataURL);\n        });\n    });\n}\n//# sourceMappingURL=util.js.map","/* tslint:disable:max-line-length */\nimport { getDataURLContent } from './util';\n// KNOWN ISSUE\n// -----------\n// Can not handle redirect-url, such as when access 'http://something.com/avatar.png'\n// will redirect to 'http://something.com/65fc2ffcc8aea7ba65a1d1feda173540'\nconst TIMEOUT = 30000;\nconst cache = {};\nfunction isFont(filename) {\n    return /ttf|otf|eot|woff2?/i.test(filename);\n}\nexport function getBlobFromURL(url, options) {\n    let href = url.replace(/\\?.*/, '');\n    if (isFont(href)) {\n        href = href.replace(/.*\\//, '');\n    }\n    if (cache[href]) {\n        return cache[href];\n    }\n    // cache bypass so we dont have CORS issues with cached images\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // tslint:disable-next-line\n        url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n    }\n    const failed = (reason) => {\n        let placeholder = '';\n        if (options.imagePlaceholder) {\n            const parts = options.imagePlaceholder.split(/,/);\n            if (parts && parts[1]) {\n                placeholder = parts[1];\n            }\n        }\n        let msg = `Failed to fetch resource: ${url}`;\n        if (reason) {\n            msg = typeof reason === 'string' ? reason : reason.message;\n        }\n        if (msg) {\n            console.error(msg);\n        }\n        return placeholder;\n    };\n    const deferred = window.fetch\n        ? window\n            .fetch(url)\n            .then((res) => res.blob().then((blob) => ({\n            blob,\n            contentType: res.headers.get('Content-Type') || '',\n        })))\n            .then(({ blob, contentType }) => new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve({\n                contentType,\n                blob: reader.result,\n            });\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n        }))\n            .then(({ blob, contentType }) => ({\n            contentType,\n            blob: getDataURLContent(blob),\n        }))\n        : new Promise((resolve, reject) => {\n            const req = new XMLHttpRequest();\n            const timeout = () => {\n                reject(new Error(`Timeout of ${TIMEOUT}ms occured while fetching resource: ${url}`));\n            };\n            const done = () => {\n                if (req.readyState !== 4) {\n                    return;\n                }\n                if (req.status !== 200) {\n                    reject(new Error(`Failed to fetch resource: ${url}, status: ${req.status}`));\n                    return;\n                }\n                const encoder = new FileReader();\n                encoder.onloadend = () => {\n                    resolve({\n                        blob: getDataURLContent(encoder.result),\n                        contentType: req.getResponseHeader('Content-Type') || '',\n                    });\n                };\n                encoder.readAsDataURL(req.response);\n            };\n            req.onreadystatechange = done;\n            req.ontimeout = timeout;\n            req.responseType = 'blob';\n            req.timeout = TIMEOUT;\n            req.open('GET', url, true);\n            req.send();\n        });\n    const promise = deferred.catch(failed);\n    // cache result\n    cache[href] = promise;\n    return promise;\n}\n//# sourceMappingURL=getBlobFromURL.js.map","import { uuid, toArray } from './util';\nvar Pseudo;\n(function (Pseudo) {\n    function clonePseudoElement(nativeNode, clonedNode, pseudo) {\n        const style = window.getComputedStyle(nativeNode, pseudo);\n        const content = style.getPropertyValue('content');\n        if (content === '' || content === 'none') {\n            return;\n        }\n        const className = uuid();\n        // fix: Cannot assign to read only property 'className' of object '#<â€¦\n        try {\n            clonedNode.className = `${clonedNode.className} ${className}`;\n        }\n        catch (err) {\n            return;\n        }\n        const styleElement = document.createElement('style');\n        styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));\n        clonedNode.appendChild(styleElement);\n    }\n    Pseudo.clonePseudoElement = clonePseudoElement;\n    function getPseudoElementStyle(className, pseudo, style) {\n        const selector = `.${className}:${pseudo}`;\n        const cssText = style.cssText\n            ? formatCssText(style)\n            : formatCssProperties(style);\n        return document.createTextNode(`${selector}{${cssText}}`);\n    }\n    function formatCssText(style) {\n        const content = style.getPropertyValue('content');\n        return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`;\n    }\n    function formatCssProperties(style) {\n        return toArray(style)\n            .map((name) => {\n            const value = style.getPropertyValue(name);\n            const priority = style.getPropertyPriority(name);\n            return `${name}: ${value}${priority ? ' !important' : ''};`;\n        })\n            .join(' ');\n    }\n})(Pseudo || (Pseudo = {}));\nexport function clonePseudoElements(nativeNode, clonedNode) {\n    const pseudos = [':before', ':after'];\n    pseudos.forEach((pseudo) => Pseudo.clonePseudoElement(nativeNode, clonedNode, pseudo));\n}\n//# sourceMappingURL=clonePseudoElements.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { clonePseudoElements } from './clonePseudoElements';\nimport { createImage, toArray, toDataURL, getMimeType } from './util';\nfunction cloneSingleNode(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (node instanceof HTMLCanvasElement) {\n            const dataURL = node.toDataURL();\n            if (dataURL === 'data:,') {\n                return Promise.resolve(node.cloneNode(false));\n            }\n            return createImage(dataURL);\n        }\n        if (node instanceof HTMLVideoElement && node.poster) {\n            return Promise.resolve(node.poster)\n                .then((url) => getBlobFromURL(url, options))\n                .then((data) => toDataURL(data.blob, getMimeType(node.poster) || data.contentType))\n                .then((dataURL) => createImage(dataURL));\n        }\n        return Promise.resolve(node.cloneNode(false));\n    });\n}\nfunction cloneChildren(nativeNode, clonedNode, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const children = toArray(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);\n        if (children.length === 0) {\n            return Promise.resolve(clonedNode);\n        }\n        return children\n            .reduce((done, child) => done\n            .then(() => cloneNode(child, options))\n            .then((clonedChild) => {\n            if (clonedChild) {\n                clonedNode.appendChild(clonedChild);\n            }\n        }), Promise.resolve())\n            .then(() => clonedNode);\n    });\n}\nfunction decorate(nativeNode, clonedNode) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return clonedNode;\n        }\n        return Promise.resolve()\n            .then(() => cloneCssStyle(nativeNode, clonedNode))\n            .then(() => clonePseudoElements(nativeNode, clonedNode))\n            .then(() => cloneInputValue(nativeNode, clonedNode))\n            .then(() => clonedNode);\n    });\n}\nfunction cloneCssStyle(nativeNode, clonedNode) {\n    const source = window.getComputedStyle(nativeNode);\n    const target = clonedNode.style;\n    if (!target) {\n        return;\n    }\n    if (source.cssText) {\n        target.cssText = source.cssText;\n    }\n    else {\n        toArray(source).forEach((name) => {\n            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (nativeNode instanceof HTMLTextAreaElement) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (nativeNode instanceof HTMLInputElement) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nexport function cloneNode(nativeNode, options, isRoot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!isRoot && options.filter && !options.filter(nativeNode)) {\n            return Promise.resolve(null);\n        }\n        return Promise.resolve(nativeNode)\n            .then((clonedNode) => cloneSingleNode(clonedNode, options))\n            .then((clonedNode) => cloneChildren(nativeNode, clonedNode, options))\n            .then((clonedNode) => decorate(nativeNode, clonedNode));\n    });\n}\n//# sourceMappingURL=cloneNode.js.map","import { getBlobFromURL } from './getBlobFromURL';\nimport { isDataUrl, toDataURL, getMimeType } from './util';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nexport function shouldEmbed(string) {\n    return string.search(URL_REGEX) !== -1;\n}\nexport function embedResources(cssString, baseUrl, options) {\n    if (!shouldEmbed(cssString)) {\n        return Promise.resolve(cssString);\n    }\n    const filteredCssString = filterPreferredFontFormat(cssString, options);\n    return Promise.resolve(filteredCssString)\n        .then(parseURLs)\n        .then((urls) => urls.reduce((done, url) => done.then((ret) => embed(ret, url, baseUrl, options)), Promise.resolve(filteredCssString)));\n}\nexport function filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function parseURLs(str) {\n    const result = [];\n    str.replace(URL_REGEX, (raw, quotation, url) => {\n        result.push(url);\n        return raw;\n    });\n    return result.filter((url) => !isDataUrl(url));\n}\nexport function embed(cssString, resourceURL, baseURL, options, get) {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n    return Promise.resolve(resolvedURL)\n        .then((url) => get ? get(url) : getBlobFromURL(url, options))\n        .then((data) => {\n        if (typeof data === 'string') {\n            return toDataURL(data, getMimeType(resourceURL));\n        }\n        return toDataURL(data.blob, getMimeType(resourceURL) || data.contentType);\n    })\n        .then((dataURL) => cssString.replace(urlToRegex(resourceURL), `$1${dataURL}$3`))\n        .then((content) => content, () => resolvedURL);\n}\nfunction resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nfunction urlToRegex(url) {\n    return new RegExp(`(url\\\\(['\"]?)(${escape(url)})(['\"]?\\\\))`, 'g');\n}\nfunction escape(url) {\n    return url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n}\n//# sourceMappingURL=embedResources.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { embedResources } from './embedResources';\nimport { toArray, isDataUrl, toDataURL, getMimeType } from './util';\nexport function embedImages(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(clonedNode)\n            .then((node) => embedBackground(node, options))\n            .then((node) => embedImageNode(node, options))\n            .then((node) => embedChildren(node, options));\n    });\n}\nfunction embedBackground(clonedNode, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const background = (_a = clonedNode.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue('background');\n        if (!background) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(background)\n            .then((cssString) => embedResources(cssString, null, options))\n            .then((cssString) => {\n            clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));\n            return clonedNode;\n        });\n    });\n}\nfunction embedImageNode(clonedNode, options) {\n    if (!(clonedNode instanceof HTMLImageElement) || isDataUrl(clonedNode.src)) {\n        return Promise.resolve(clonedNode);\n    }\n    const src = clonedNode.src;\n    return Promise.resolve(src)\n        .then((url) => getBlobFromURL(url, options))\n        .then((data) => toDataURL(data.blob, getMimeType(src) || data.contentType))\n        .then((dataURL) => new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        clonedNode.srcset = '';\n        clonedNode.src = dataURL;\n    }))\n        .then(() => clonedNode, () => clonedNode);\n}\nfunction embedChildren(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const children = toArray(clonedNode.childNodes);\n        const deferreds = children.map((child) => embedImages(child, options));\n        return Promise.all(deferreds).then(() => clonedNode);\n    });\n}\n//# sourceMappingURL=embedImages.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { toArray } from './util';\nimport { shouldEmbed, embedResources } from './embedResources';\nconst cssFetchPromiseStore = {};\nexport function parseWebFontRules(clonedNode) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            if (!clonedNode.ownerDocument) {\n                reject(new Error('Provided element is not within a Document'));\n            }\n            resolve(toArray(clonedNode.ownerDocument.styleSheets));\n        })\n            .then((styleSheets) => getCssRules(styleSheets))\n            .then(getWebFontRules);\n    });\n}\nexport function embedWebFonts(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return (options.fontEmbedCss != null\n            ? Promise.resolve(options.fontEmbedCss)\n            : getWebFontCss(clonedNode, options)).then((cssString) => {\n            const styleNode = document.createElement('style');\n            const sytleContent = document.createTextNode(cssString);\n            styleNode.appendChild(sytleContent);\n            if (clonedNode.firstChild) {\n                clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n            }\n            else {\n                clonedNode.appendChild(styleNode);\n            }\n            return clonedNode;\n        });\n    });\n}\nexport function getWebFontCss(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return parseWebFontRules(node)\n            .then((rules) => Promise.all(rules.map((rule) => {\n            const baseUrl = rule.parentStyleSheet\n                ? rule.parentStyleSheet.href\n                : null;\n            return embedResources(rule.cssText, baseUrl, options);\n        })))\n            .then((cssStrings) => cssStrings.join('\\n'));\n    });\n}\nexport function getCssRules(styleSheets) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const ret = [];\n        const promises = [];\n        // First loop inlines imports\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules).forEach((item, index) => {\n                        if (item.type === CSSRule.IMPORT_RULE) {\n                            let importIndex = index + 1;\n                            promises.push(fetchCSS(item.href, sheet)\n                                .then(embedFonts)\n                                .then((cssText) => {\n                                const parsed = parseCSS(cssText);\n                                parsed.forEach((rule) => {\n                                    try {\n                                        sheet.insertRule(rule, rule.startsWith('@import')\n                                            ? (importIndex = importIndex + 1)\n                                            : sheet.cssRules.length);\n                                    }\n                                    catch (error) {\n                                        console.log('Error inserting rule from remote css', {\n                                            rule,\n                                            error,\n                                        });\n                                    }\n                                });\n                            })\n                                .catch((e) => {\n                                console.log('Error loading remote css', e.toString());\n                            }));\n                        }\n                    });\n                }\n                catch (e) {\n                    const inline = styleSheets.find((a) => a.href === null) || document.styleSheets[0];\n                    if (sheet.href != null) {\n                        promises.push(fetchCSS(sheet.href, inline)\n                            .then(embedFonts)\n                            .then((cssText) => {\n                            const parsed = parseCSS(cssText);\n                            parsed.forEach((rule) => {\n                                inline.insertRule(rule, sheet.cssRules.length);\n                            });\n                        })\n                            .catch((e) => {\n                            console.log('Error loading remote stylesheet', e.toString());\n                        }));\n                    }\n                    console.log('Error inlining remote css file', e.toString());\n                }\n            }\n        });\n        return Promise.all(promises).then(() => {\n            // Second loop parses rules\n            styleSheets.forEach((sheet) => {\n                if ('cssRules' in sheet) {\n                    try {\n                        toArray(sheet.cssRules).forEach((item) => {\n                            ret.push(item);\n                        });\n                    }\n                    catch (e) {\n                        console.log(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n                    }\n                }\n            });\n            return ret;\n        });\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nfunction parseCSS(source) {\n    if (source === undefined) {\n        return [];\n    }\n    let cssText = source;\n    const css = [];\n    const cssKeyframeRegex = '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})';\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'; // to match css & media queries together\n    const cssCommentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // strip out comments\n    cssText = cssText.replace(cssCommentsRegex, '');\n    const keyframesRegex = new RegExp(cssKeyframeRegex, 'gi');\n    let arr;\n    while (true) {\n        arr = keyframesRegex.exec(cssText);\n        if (arr === null) {\n            break;\n        }\n        css.push(arr[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    // unified regex\n    const unified = new RegExp(combinedCSSRegex, 'gi');\n    while (true) {\n        arr = importRegex.exec(cssText);\n        if (arr === null) {\n            arr = unified.exec(cssText);\n            if (arr === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unified.lastIndex;\n            }\n        }\n        else {\n            unified.lastIndex = importRegex.lastIndex;\n        }\n        css.push(arr[0]);\n    }\n    return css;\n}\nfunction fetchCSS(url, sheet) {\n    if (cssFetchPromiseStore[url]) {\n        return cssFetchPromiseStore[url];\n    }\n    const promise = fetch(url).then((res) => {\n        return {\n            url,\n            cssText: res.text(),\n        };\n    }, (e) => {\n        console.log('ERROR FETCHING CSS: ', e.toString());\n    });\n    cssFetchPromiseStore[url] = promise;\n    return promise;\n}\nfunction embedFonts(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return data.cssText.then((resolved) => {\n            let cssText = resolved;\n            const regexUrlFind = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n            const fontLocations = cssText.match(/url\\([^)]+\\)/g) || [];\n            const fontLoadedPromises = fontLocations.map((location) => {\n                let url = location.replace(regexUrlFind, '$1');\n                if (!url.startsWith('https://')) {\n                    const source = data.url;\n                    url = new URL(url, source).href;\n                }\n                return new Promise((resolve, reject) => {\n                    fetch(url)\n                        .then((res) => res.blob())\n                        .then((blob) => {\n                        const reader = new FileReader();\n                        reader.addEventListener('load', (res) => {\n                            // Side Effect\n                            cssText = cssText.replace(location, `url(${reader.result})`);\n                            resolve([location, reader.result]);\n                        });\n                        reader.readAsDataURL(blob);\n                    })\n                        .catch(reject);\n                });\n            });\n            return Promise.all(fontLoadedPromises).then(() => cssText);\n        });\n    });\n}\n//# sourceMappingURL=embedWebFonts.js.map","import { svgToDataURL } from './util';\nexport function createSvgDataURL(clonedNode, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttributeNS('', 'width', `${width}`);\n    svg.setAttributeNS('', 'height', `${height}`);\n    svg.setAttributeNS('', 'viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttributeNS('', 'width', '100%');\n    foreignObject.setAttributeNS('', 'height', '100%');\n    foreignObject.setAttributeNS('', 'x', '0');\n    foreignObject.setAttributeNS('', 'y', '0');\n    foreignObject.setAttributeNS('', 'externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(clonedNode);\n    return svgToDataURL(svg);\n}\n//# sourceMappingURL=createSvgDataURL.js.map","export function applyStyleWithOptions(clonedNode, options) {\n    const { style } = clonedNode;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            // @ts-expect-error\n            style[key] = manual[key];\n        });\n    }\n    return clonedNode;\n}\n//# sourceMappingURL=applyStyleWithOptions.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { cloneNode } from './cloneNode';\nimport { embedImages } from './embedImages';\nimport { embedWebFonts, getWebFontCss } from './embedWebFonts';\nimport { createSvgDataURL } from './createSvgDataURL';\nimport { applyStyleWithOptions } from './applyStyleWithOptions';\nimport { delay, createImage, canvasToBlob, getNodeWidth, getNodeHeight, getPixelRatio, } from './util';\nfunction getImageSize(domNode, options = {}) {\n    const width = options.width || getNodeWidth(domNode);\n    const height = options.height || getNodeHeight(domNode);\n    return { width, height };\n}\nexport function toSvg(domNode, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(domNode, options);\n        return cloneNode(domNode, options, true)\n            .then((clonedNode) => embedWebFonts(clonedNode, options))\n            .then((clonedNode) => embedImages(clonedNode, options))\n            .then((clonedNode) => applyStyleWithOptions(clonedNode, options))\n            .then((clonedNode) => createSvgDataURL(clonedNode, width, height));\n    });\n}\nexport const toSvgDataURL = toSvg;\nexport function toCanvas(domNode, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toSvg(domNode, options)\n            .then(createImage)\n            .then(delay(100))\n            .then((image) => {\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            const ratio = options.pixelRatio || getPixelRatio();\n            const { width, height } = getImageSize(domNode, options);\n            const canvasWidth = options.canvasWidth || width;\n            const canvasHeight = options.canvasHeight || height;\n            canvas.width = canvasWidth * ratio;\n            canvas.height = canvasHeight * ratio;\n            canvas.style.width = `${canvasWidth}`;\n            canvas.style.height = `${canvasHeight}`;\n            if (options.backgroundColor) {\n                context.fillStyle = options.backgroundColor;\n                context.fillRect(0, 0, canvas.width, canvas.height);\n            }\n            context.drawImage(image, 0, 0, canvas.width, canvas.height);\n            return canvas;\n        });\n    });\n}\nexport function toPixelData(domNode, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(domNode, options);\n        return toCanvas(domNode, options).then((canvas) => {\n            const ctx = canvas.getContext('2d');\n            return ctx.getImageData(0, 0, width, height).data;\n        });\n    });\n}\nexport function toPng(domNode, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(domNode, options).then((canvas) => canvas.toDataURL());\n    });\n}\nexport function toJpeg(domNode, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(domNode, options).then((canvas) => canvas.toDataURL('image/jpeg', options.quality || 1));\n    });\n}\nexport function toBlob(domNode, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(domNode, options).then(canvasToBlob);\n    });\n}\nexport function getWebFontEmbedCss(domNode, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return getWebFontCss(domNode, options);\n    });\n}\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}